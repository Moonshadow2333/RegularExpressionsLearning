### 重复匹配
不管是字符集合还是元字符都只能匹配一个字符，有很大的局限性。
#### +：匹配一个或多个字符
作用：匹配某个重复一次或多次的某个字符（或字符集合）。
注意：在给一个字符集合加上+后缀时，必须把+放在这个字符集合的外面。例如[0-9]+是正确的，[0-9+]则不符合预期。
#### *：匹配零个或多个字符
作用：匹配一个可有可无的字符，也就是该字符可以出现零次或多次。
注意：`*`是一个元字符。如果要匹配`*`本身，则需要转义，即`\*`;

#### ?：匹配零个或一个字符
作用：`?`非常适合匹配一段文本中**某个特定可选字符**。
注意：`?`是一个元字符。如果要匹配`?`本身，则需要转义，即`\?`;

#### 匹配的重复次数
1. 具体的重复匹配。
例如：a{6}。即匹配6个连续的a。
通式：{n}
2. 区间范围。
例如：a{2,4}。即最少匹配2个连续的a，最多匹配4个连续的a。
通式：{min,max}
3. 至少重复多少次。
例如：a{3,}。即最少匹配3个连续的a，上不封顶。
通式：{min,}
注意：`{}`是元字符。如果要匹配自身，则需要转义。`\{\}`。
#### 防止过度匹配。
1. 贪婪行为
例子：
```
This offer is not available to 
costomers living in <b>AK</b> and <b>HI</b>.
正则表达式：
<[Bb]>.*<\/[Bb]>

```
结果：
This offer is not available to 
costomers living in `<b>AK</b> and <b>HI</b>`.（打开预览模式查看结果...）
分析：
- `.`匹配任意单个字符，`*`匹配0次或多次。
- `.`可以匹配`<`、`/`、`b`、`>`，而`*`元字符可以让`.`一直重复下去，直到字符串的结尾，无法匹配了，就开始让`<`去匹配了，匹配失败就退一个字符，直到遇到句子中`</b>`的左尖括号，然后就让`/`去匹配，以此类推，就得到了最终的结果。
-  It will reduce the repetition of the plus by one, and then continue trying the remainder of the regex.
**正则引擎让.(点)一条路走到黑，不撞南墙不回头，匹配失败后，让正则表达式的下一字符与字符串进行匹配，匹配失败，字符串则扔一个字符，直到匹配成功。**
2. 懒惰行为：
例子：
```
This offer is not available to 
costomers living in <b>AK</b> and <b>HI</b>.
正则表达式：
<[Bb]>.*?<\/[Bb]>

```
结果：
This offer is not available to 
costomers living in `<b>AK</b>` and `<b>HI</b>`.
分析：
- `*?`是懒惰型量词。
- 如果用了`*?`去修饰`.`，正则引擎会先跳过`.`，让下一字符与字符串进行匹配，如果成功，则让下下字符与字符串进行匹配；如果失败，则退一步让`.`与字符串进行匹配。

**正则引擎首先跳过.(点)，让下一字符与字符串进行匹配，如果成功则进一步，让下一字符与该串进行匹配，如果失败则退一步，让.(点)与该串进行匹配。**